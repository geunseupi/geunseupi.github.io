<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>근스피</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js and necessary plugins for Time Series and Zoom/Pan -->
    
    <script src="https://cdn.jsdelivr.net/npm/hammerjs/hammer.min.js"></script> <!-- 요청하신 Hammer.js 포함 -->
    <!-- Chart.js v4+ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- chartjs-plugin-zoom v2.2.0 (최신 버전으로 업데이트) -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0"></script>

    <style>
        /* 폰트 설정 및 기본 스타일 */
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f9; }
        #chartContainer { max-width: 1200px; margin: 0 auto; }
        /* 차트 캔버스 스타일 */
        .chart-canvas { 
            background-color: white; 
            border-radius: 1rem; 
            padding: 1rem; 
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); 
            /* 내부 콘텐츠(캔버스)가 부모 크기에 맞도록 flex 설정 */
            display: flex; 
            flex-direction: column; 
            /* 텍스트 선택 방지 CSS는 유지 */
            user-select: none; 
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
            touch-action: none; /* 터치 이벤트 충돌 방지 */
        }
        /* 로딩 인디케이터 */
        #loadingIndicator {
            display: none; /* 초기에는 숨김 */
            position: absolute;
            inset: 0;
            background-color: rgba(255, 255, 255, 0.9);
            z-index: 10;
            border-radius: 1rem;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-blue': '#10b981', /* 에메랄드 그린 계열 */
                        'primary-dark': '#0f766e',
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 md:p-8">

    <div id="chartContainer" class="space-y-6">
        <h1 class="text-3xl font-bold text-gray-800 text-center">
            근스피
        </h1>

        <!-- 차트 컨트롤 -->
        <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200">
             <div class="flex flex-col sm:flex-row justify-center">
                <button onclick="resetZoom()" id="resetButton" class="w-full sm:w-1/2 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-200 ease-in-out shadow-md hover:shadow-lg">
                    🔄 차트 초기화 (Zoom/Pan 리셋)
                </button>
            </div>
            <p id="statusMessage" class="mt-4 text-sm text-red-500 font-medium hidden text-center"></p>
        </div>

        <!-- 차트 캔버스 (높이 조정됨) -->
        <div class="chart-canvas h-[500px] max-h-[70vh] relative">
            <div id="loadingIndicator" class="flex items-center justify-center text-lg font-medium text-gray-700">
                CSV 데이터를 불러오는 중...
            </div>
            
            <canvas id="timeSeriesChart" class="flex-1"></canvas>
        </div>

        <p class="text-sm text-gray-500 mt-4 text-center" id="lastUpdated">
            데이터 로드 대기 중...
        </p>
    </div>

    <script>
        let myChart; // Chart.js 인스턴스를 저장할 전역 변수
        const CSV_URL = 'data.csv'; // GitHub Pages에서 읽어올 파일명
        const UPDATE_INTERVAL_MS = 5 * 60 * 1000; // 5분
        const TWELVE_HOURS_IN_MS = 12 * 60 * 60 * 1000; // 12시간을 밀리초로 정의
        
        /**
         * CSV 텍스트를 Chart.js 데이터 형식으로 파싱합니다.
         */
        function parseCsvData(csvText) {
            const rows = csvText.trim().split('\n');
            if (rows.length < 2) return [];

            const header = rows[0].split(',').map(h => h.trim().toLowerCase());
            const data = [];
            
            // 헤더에서 timestamp와 value 인덱스를 찾습니다.
            const timeIndex = header.indexOf('timestamp');
            const valueIndex = header.indexOf('value');

            if (timeIndex === -1 || valueIndex === -1) {
                throw new Error("CSV 헤더에 'timestamp' 또는 'value'가 포함되어야 합니다.");
            }

            for (let i = 1; i < rows.length; i++) {
                const cols = rows[i].split(',').map(c => c.trim());
                
                if (cols.length > Math.max(timeIndex, valueIndex)) {
                    const timestamp = new Date(cols[timeIndex]);
                    const value = parseFloat(cols[valueIndex]);

                    // 유효한 데이터만 추가
                    if (!isNaN(timestamp.getTime()) && !isNaN(value)) {
                        data.push({ x: timestamp.getTime(), y: value });
                    }
                }
            }
            
            // 데이터를 시간 순으로 정렬합니다. (Chart.js time scale 요구사항)
            data.sort((a, b) => a.x - b.x);
            return data;
        }
        
        /**
         * GitHub Pages의 data.csv 파일을 비동기적으로 가져옵니다.
         */
        async function fetchData() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            const lastUpdatedElement = document.getElementById('lastUpdated');
            const statusMessage = document.getElementById('statusMessage');

            loadingIndicator.style.display = 'flex';
            statusMessage.classList.add('hidden');
            lastUpdatedElement.textContent = '데이터를 불러오는 중...';

            try {
                // 캐시 문제 해결을 위해 쿼리 파라미터에 현재 시간을 추가합니다.
                const urlWithCacheBuster = `${CSV_URL}?v=${Date.now()}`;
                
                const response = await fetch(urlWithCacheBuster, { cache: "no-store" });
                
                if (!response.ok) {
                    throw new Error(`HTTP 오류: ${response.status} (${response.statusText}). GitHub에 ${CSV_URL} 파일이 올바르게 커밋되었는지 확인하세요.`);
                }
                
                const csvText = await response.text();
                const dataPoints = parseCsvData(csvText);
                
                if (dataPoints.length === 0) {
                     throw new Error("CSV 파일을 읽었으나 유효한 데이터 포인트가 없습니다. 헤더와 데이터 형식을 확인하세요.");
                }

                updateChart(dataPoints);
                
                lastUpdatedElement.textContent = `✅ 마지막 업데이트: ${new Date().toLocaleTimeString('ko-KR')}`;
                
            } catch (error) {
                console.error("데이터 로드 및 파싱 실패:", error);
                statusMessage.textContent = `🚨 데이터 로드 오류: ${error.message}`;
                statusMessage.classList.remove('hidden');
                lastUpdatedElement.textContent = '❌ 데이터 로드 실패';
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        /**
         * Y축 스케일을 현재 보이는 데이터 범위에 맞게 조정합니다.
         */
        const autoAdjustYScale = ({ chart }) => {
            const xScale = chart.scales.x;
            const dataPoints = chart.data.datasets[0].data; 
            
            const xMin = xScale.min;
            const xMax = xScale.max;
            
            let yValues = [];
            
            for (const point of dataPoints) {
                // point.x는 타임스탬프 (숫자)
                if (point.x >= xMin && point.x <= xMax) {
                    yValues.push(point.y);
                }
            }
            
            if (yValues.length > 0) {
                const minY = Math.min(...yValues);
                const maxY = Math.max(...yValues);

                const padding = (maxY - minY) * 0.05;
                const newMinY = minY - padding;
                const newMaxY = maxY + padding;

                const yScale = chart.scales.y;
                
                yScale.min = newMinY < 0 ? 0 : newMinY;
                yScale.max = newMaxY;
                
                chart.update('none'); 
            } else {
                 chart.scales.y.min = undefined;
                 chart.scales.y.max = undefined;
                 chart.update('none');
            }
        };

        /**
         * 차트 인스턴스를 생성하거나 기존 인스턴스의 데이터를 업데이트합니다.
         */
        function updateChart(dataPoints) {
            const ctx = document.getElementById('timeSeriesChart').getContext('2d');
            
            const data = {
                datasets: [{
                    label: '시계열 값 (Value)',
                    data: dataPoints,
                    borderColor: 'rgb(16, 185, 129)', 
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    pointRadius: 1, 
                    pointHoverRadius: 5,
                    tension: 0.1, 
                    fill: false
                }]
            };

            const config = {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false, 
                    animation: false, 
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'yyyy-MM-dd HH:mm:ss'
                            },
                            title: { display: true, text: '시간 (Timestamp)', color: '#4b5563' },
                            grid: { color: 'rgba(0, 0, 0, 0.05)' }
                        },
                        y: {
                            beginAtZero: false,
                            title: { display: true, text: '값 (Value)', color: '#4b5563' },
                            grid: { color: 'rgba(0, 0, 0, 0.05)' }
                        }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' },
                        tooltip: { mode: 'index', intersect: false },
                        zoom: {
                            zoom: {
                                enabled: true, 
                                wheel: { enabled: true, modifierKey: null }, // Shift 키 없이 휠 줌
                                pinch: { enabled: true },
                                mode: 'x', 
                                speed: 0.1,
                                duration: 0, 
                                onZoomComplete: autoAdjustYScale, 
                            },
                            pan: {
                                enabled: true,
                                mode: 'x', 
                                threshold: 5,
                                modifierKey: null, // Shift 키 없이 드래그 Pan
                                onPanComplete: autoAdjustYScale, 
                            },
                            limits: { x: { min: 'original', max: 'original' } } 
                        }
                    }
                }
            };

            // --- [새로운 기능] 초기 12시간 뷰 설정 ---
            if (dataPoints.length > 0) {
                const latestTime = dataPoints[dataPoints.length - 1].x; // 가장 최신 타임스탬프 (밀리초)
                const startTime = latestTime - TWELVE_HOURS_IN_MS; // 12시간 전 시간 계산

                // X축 초기 범위 설정
                config.options.scales.x.min = startTime;
                config.options.scales.x.max = latestTime;
            }
            // --- [새로운 기능] 끝 ---

            if (myChart) {
                // 기존 차트 업데이트
                myChart.data.datasets[0].data = dataPoints;
                // 기존 차트의 옵션에도 12시간 범위 적용 (업데이트 시 리셋되지 않도록)
                myChart.options.scales.x.min = config.options.scales.x.min;
                myChart.options.scales.x.max = config.options.scales.x.max;
                
                myChart.update();
                autoAdjustYScale({ chart: myChart });
            } else {
                // 새 차트 생성
                myChart = new Chart(ctx, config);
                autoAdjustYScale({ chart: myChart });
            }
            document.getElementById('resetButton').disabled = false;
        }

        /**
         * 줌 및 팬 상태를 초기화합니다.
         */
        function resetZoom() {
            if (myChart && myChart.resetZoom) {
                // resetZoom()은 X축을 전체 데이터 범위로 되돌립니다.
                myChart.resetZoom();
                
                // 줌 리셋 후 Y축도 초기 전체 데이터 범위로 재조정
                myChart.scales.y.min = undefined;
                myChart.scales.y.max = undefined;
                myChart.update('none');
            }
        }

        // 초기 로드 시 차트 렌더링 및 5분마다 업데이트 설정.
        window.onload = () => {
             fetchData();
             // 5분마다 데이터 새로고침
             setInterval(fetchData, UPDATE_INTERVAL_MS);
        };

    </script>
</body>
</html>
